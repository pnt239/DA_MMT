// Vaca - Visual Application Components Abstraction
// Copyright (c) 2005, 2006, 2007, 2008, David A. Capello
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
//
// * Redistributions of source code must retain the above copyright
//   notice, this list of conditions and the following disclaimer.
// * Redistributions in binary form must reproduce the above copyright
//   notice, this list of conditions and the following disclaimer in
//   the documentation and/or other materials provided with the
//   distribution.
// * Neither the name of the Vaca nor the names of its contributors
//   may be used to endorse or promote products derived from this
//   software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
// FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
// COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
// OF THE POSSIBILITY OF SUCH DAMAGE.

#ifndef VACA_EXCEPTION_H
#define VACA_EXCEPTION_H

#include <exception>

#include "Vaca/String.h"

namespace Vaca {

/**
 * Exception generated from Vaca.
 * 
 * Base class for every exception generated by Vaca objects.
 */
class Exception : public std::exception
{
  String m_message;
  DWORD m_errorCode;
  LPSTR m_msgbuf;

public:

  /**
   * Creates generic exception with an empty error message.
   */
  Exception()
    : std::exception()
  {
    m_errorCode = GetLastError();
    m_msgbuf = NULL;
  }

  /**
   * Creates an exception with the specified error message.
   *
   * @param message Error message.
   */
  Exception(const String& message)
    : std::exception()
    , m_message(message)
  {
    m_errorCode = GetLastError();

    if (!FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER | 
			FORMAT_MESSAGE_FROM_SYSTEM | 
			FORMAT_MESSAGE_IGNORE_INSERTS,
			NULL,
			m_errorCode,
			MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
			reinterpret_cast<LPSTR>(&m_msgbuf),
			0, NULL))
      m_msgbuf = NULL;
  }

  /**
   * Destroys the exception.
   */
  virtual ~Exception() throw()
  {
    LocalFree(m_msgbuf);
  }

  /**
   * Returns a printable C-string of the error.
   *
   * If the Exception(const String&) constructor was used to
   * create the exception, this method returns the same string
   * as #getMessage but in ASCII format.
   */
  virtual const char* what() const throw()
  {
    return m_msgbuf ? m_msgbuf: "Vaca::Exception";
  }

  /**
   * Returns the error message specified in the creation of the
   * exception.
   *
   * @see Exception(const String&)
   */
  virtual const String& getMessage() const throw()
  {
    return m_message;
  }

  /**
   * Shows the error in a MsgBox.
   *
   * @warning The MsgBox doesn't lock any Frame. It's like a dialog
   *          running in background.
   *
   * @win32
   *   It is like call MessageBox(NULL, getMessage(), ...);
   * @endwin32
   */
  void show()
  {
    String msg = getMessage();
    if (m_errorCode != ERROR_SUCCESS) {
      if (!msg.empty())
	msg += _T("\r\n\r\n");
      msg += String(what());
    }
    MessageBox(NULL, msg.c_str(), _T("Exception"),
	       MB_OK | MB_ICONERROR | MB_SYSTEMMODAL);
  }

};

} // namespace Vaca

#endif // VACA_EXCEPTION_H
